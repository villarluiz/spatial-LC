seq(2000, 1000, by = 1)
seq(2000, 1000, by = 2)
seq(1000, 2000, by = 2)
seq(1000, 2000, by = 1)
sblc <- function(y, ages, t, n, m0, C0, M, W, it, bn, thin){
y_obs = y
### CHAINS
kappa.chain <- matrix(NA, nrow = it, ncol = t+1)
alpha.chain <- matrix(NA, nrow = it, ncol = ages)
beta.chain <- matrix(NA, nrow = it, ncol = ages)
gamma.chain <- matrix(NA, nrow = it, ncol = ages)
theta.chain <- matrix(NA, nrow = it, ncol = n)
sigma_w.chain <- rep(NA, it)
sigma_e.chain <- rep(NA, it)
sigma_t.chain <- rep(NA, it)
nu.chain <- rep(NA, it)
### STARTERS
alpha.chain[1, ] <- runif(ages)
beta.chain[1, ] <- runif(ages)
beta.chain[1, ] <- beta.chain[1, ]/sum(beta.chain[1, ])
gamma.chain[1, ] <- runif(ages)
gamma.chain[1, ] <- gamma.chain[1, ]/sum(gamma.chain[1, ])
theta.chain[1, ] <- runif(n)
theta.chain[1, ] <- theta.chain[1, ] - mean(theta.chain[1, ])
sigma_w.chain[1] <- 1
sigma_e.chain[1] <- 1
sigma_t.chain[1] <- 1
nu.chain[1] <- runif(1, -1, 1)
### GIBBS
pb  = progress::progress_bar$new(format = "Simulating [:bar] :percent in :elapsed",total = it, clear = FALSE, width = 60)
pb$tick()
prop = 0
set.seed(16)
for(i in 2:it){
pb$tick()
### KAPPA
fit <- ffbs_sp(y_obs = y_obs, ages = ages, t = t, n = n, m0 = m0, C0 = C0,
sigma_e = sigma_e.chain[i-1],
sigma_w = sigma_w.chain[i-1],
nu = nu.chain[i-1],
alpha = alpha.chain[i-1, ],
beta = beta.chain[i-1, ],
gamma = gamma.chain[i-1, ],
theta = theta.chain[i-1, ])
kappa.chain[i, 2:(t+1)] <- fit$kappa.bs
kappa.chain[i, 1] <- fit$kappa0.bs
### KAPPA CONSTRAINT
kappa.chain[i,] <- kappa.chain[i, ] - mean(kappa.chain[i, ])
### SIGMA_E
A <- matrix(kronecker(rep(1, n), alpha.chain[i-1, ]))
B <- matrix(kronecker(rep(1, n), beta.chain[i-1, ]))
C <- matrix(kronecker(theta.chain[i-1, ], gamma.chain[i-1, ]))
aux <- sum( (y_obs - A[, rep(1, t)] - (B %*% kappa.chain[i, 2:(t+1)]) - C[, rep(1, t)])^2 )
sigma_e.chain[i] <- invgamma::rinvgamma(1, t*n*ages/2, rate = aux/2) ##gerar fixando idade?
### informative priors - gamma(a, b), a = 0.01, b = 0.01
### ALPHA, BETA AND GAMMA
for (j in 1:ages) {
Y.aux <- c( y_obs[j, ] )
for(k in 2:n){
Y.aux <- c( Y.aux, y_obs[( j + (ages * (k-1)) ), ] )
}
X <- cbind(1, rep(kappa.chain[i, 2:(t+1)], n), rep(theta.chain[i-1, ], each = t))
aux.reg <- chol2inv(chol(t(X) %*% X))
mean.reg <- aux.reg %*% t(X) %*% matrix(Y.aux)
var.reg <- sigma_e.chain[i] * aux.reg
tmp <- MASS::mvrnorm(1, mean.reg, var.reg)
alpha.chain[i, j] <- tmp[1]
beta.chain[i, j] <- tmp[2]
gamma.chain[i, j] <- tmp[3]
}
### BETA & GAMMA CONSTRAINT
beta.chain[i, ] <- beta.chain[i, ]/sum(beta.chain[i, ])
gamma.chain[i, ] <- gamma.chain[i, ]/sum(gamma.chain[i, ])
### SIGMA_W
aux <- sum( (kappa.chain[i, 2:(t+1)] - nu.chain[i-1] - kappa.chain[i, 1:t])^2 ) ## years
sigma_w.chain[i] <- invgamma::rinvgamma(1, (t-1)/2, rate = aux/2)
### informative priors - gamma(a, b), a = 0.01, b = 0.01
### NU
aux <- sigma_w.chain[i]/(t-1)
aux.2 <- (kappa.chain[i, t+1] - kappa.chain[i, 1])/t
nu.chain[i] <- rnorm(1, aux.2, sqrt(aux))
#nu.chain[i] <- nu
### SIGMA_T
aux <- M - W
aux.2 <- theta.chain[i-1, ] %*% aux %*% matrix(theta.chain[i-1, ])
sigma_t.chain[i] <- invgamma::rinvgamma(1, (n-1)/2, rate = aux.2/2)
### THETA_q
for(j in 1:n){
mu0 = sum( (W[j, -j]/M[j,j])*theta.chain[i-1, -j] )
sigma0 = sigma_t.chain[i]/M[j,j]
y.hat = ( y_obs[1:ages + ages*(j-1), ] - (matrix(beta.chain[i,]) %*% kappa.chain[i, 2:(t+1)]) - matrix(alpha.chain[i,],
nrow = ages,
ncol = t) )
aux = ( sigma0*(t*sum(gamma.chain[i,]^2)) + sigma_e.chain[i] )
aux.2 = y.hat*matrix(gamma.chain[i,], nrow = ages, ncol = t)
mu1 = ( sigma0*sum(aux.2) + sigma_e.chain[i]*mu0 )/aux
sigma1 = (sigma_e.chain[i]*sigma0)/aux
theta.chain[i,j] <- rnorm(1, mu1, sqrt(sigma1))
}
### THETA CONSTRAINT
theta.chain[i,] <- theta.chain[i,] - mean(theta.chain[i,])
}
### CHAIN TREATMENT
kappa.est <- apply(kappa.chain[seq(bn, it, by = thin), 2:41], 2, quantile, c(0.025, 0.5, 0.975))
kappa0.est <- quantile(kappa.chain[seq(bn, it, by = thin), 1], c(0.025, 0.5, 0.975))
alpha.est <- apply(alpha.chain[seq(bn, it, by = thin), ], 2, quantile, c(0.025, 0.5, 0.975))
beta.est <- apply(beta.chain[seq(bn, it, by = thin), ], 2, quantile, c(0.025, 0.5, 0.975))
gamma.est <- apply(gamma.chain[seq(bn, it, by = thin), ], 2, quantile, c(0.025, 0.5, 0.975))
theta.est <- apply(theta.chain[seq(bn, it, by = thin), ], 2, quantile, c(0.025, 0.5, 0.975))
sigma_w.est <- quantile(sigma_w.chain[seq(bn, it, by = thin)], c(0.025, 0.5, 0.975))
sigma_t.est <- quantile(sigma_t.chain[seq(bn, it, by = thin)], c(0.025, 0.5, 0.975))
sigma_e.est <- quantile(sigma_e.chain[seq(bn, it, by = thin)], c(0.025, 0.5, 0.975))
nu.est <- quantile(nu.chain[seq(bn, it, by = thin)], c(0.025, 0.5, 0.975))
### RETURN
fit <- list(info = list(y = y_obs,
ages = ages,
t = t,
n = n,
m0 = m0,
C0 = C0,
M = M,
W = W,
it = it,
bn = bn,
thin = thin),
kappa = kappa.est,
kappa0 = kappa0.est,
alpha = alpha.est,
beta = beta.est,
gamma = gamma.est,
theta = theta.est,
sigma_w = sigma_w.est,
sigma_e = sigma_e.est,
sigma_t = sigma_t.est,
nu = nu.est)
}
fit <- sblc(y_treat, ages, t, n, m0, C0, M, W, it = 1000, bn = 500, thin = 1)
lines(1:t, fit$kappa.est[2, ])
plot(1:t, fit$kappa.est[2, ])
plot(1:t, fit$kappa.est[2, ])
fit$kappa
plot(1:t, fit$kappa[2, ])
plot(1:40, fit$kappa[2, ])
plot(1:ages, alpha)
plot(1:ages, alpha.[2,])
plot(1:ages, fit$alpha[2,])
lines(1:ages, fit$alpha[1,], lty = 2, col = "blue")
lines(1:ages, fit$alpha[3,], lty = 2, col = "blue")
plot(1:ages, fit$alpha[2,], lty = 2)
plot(1:ages, fit$alpha[2,], type="l")
plot(1:ages, fit$beta[2,], type="l")
lines(1:ages, fit$beta[1,], lty = 2, col = "blue")
lines(1:ages, fit$beta[3,], lty = 2, col = "blue")
plot(1:ages, fit$gamma[2,], type="l")
lines(1:ages, fit$gamma[1,], lty = 2, col = "blue")
lines(1:ages, fit$gamma[3,], lty = 2, col = "blue")
plot(1:ages, fit$theta[2,], type="l")
plot(1:n, fit$theta[2,], type="l")
lines(1:n, fit$theta[1,], lty = 2, col = "blue")
lines(1:n, fit$theta[3,], lty = 2, col = "blue")
fit$nu
fit$sigma_w
fit$sigma_e
fit$sigma_t
sblc <- function(y, ages, t, n, m0, C0, M, W, it, bn, thin){
y_obs = y
### CHAINS
kappa.chain <- matrix(NA, nrow = it, ncol = t+1)
alpha.chain <- matrix(NA, nrow = it, ncol = ages)
beta.chain <- matrix(NA, nrow = it, ncol = ages)
gamma.chain <- matrix(NA, nrow = it, ncol = ages)
theta.chain <- matrix(NA, nrow = it, ncol = n)
sigma_w.chain <- rep(NA, it)
sigma_e.chain <- rep(NA, it)
sigma_t.chain <- rep(NA, it)
nu.chain <- rep(NA, it)
### STARTERS
alpha.chain[1, ] <- runif(ages)
beta.chain[1, ] <- runif(ages)
beta.chain[1, ] <- beta.chain[1, ]/sum(beta.chain[1, ])
gamma.chain[1, ] <- runif(ages)
gamma.chain[1, ] <- gamma.chain[1, ]/sum(gamma.chain[1, ])
theta.chain[1, ] <- runif(n)
theta.chain[1, ] <- theta.chain[1, ] - mean(theta.chain[1, ])
sigma_w.chain[1] <- 1
sigma_e.chain[1] <- 1
sigma_t.chain[1] <- 1
nu.chain[1] <- runif(1, -1, 1)
### GIBBS
pb  = progress::progress_bar$new(format = "Simulating [:bar] :percent in :elapsed",total = it, clear = FALSE, width = 60)
pb$tick()
prop = 0
set.seed(16)
for(i in 2:it){
pb$tick()
### KAPPA
fit <- ffbs_sp(y_obs = y_obs, ages = ages, t = t, n = n, m0 = m0, C0 = C0,
sigma_e = sigma_e.chain[i-1],
sigma_w = sigma_w.chain[i-1],
nu = nu.chain[i-1],
alpha = alpha.chain[i-1, ],
beta = beta.chain[i-1, ],
gamma = gamma.chain[i-1, ],
theta = theta.chain[i-1, ])
kappa.chain[i, 2:(t+1)] <- fit$kappa.bs
kappa.chain[i, 1] <- fit$kappa0.bs
### KAPPA CONSTRAINT
kappa.chain[i,] <- kappa.chain[i, ] - mean(kappa.chain[i, ])
### SIGMA_E
A <- matrix(kronecker(rep(1, n), alpha.chain[i-1, ]))
B <- matrix(kronecker(rep(1, n), beta.chain[i-1, ]))
C <- matrix(kronecker(theta.chain[i-1, ], gamma.chain[i-1, ]))
aux <- sum( (y_obs - A[, rep(1, t)] - (B %*% kappa.chain[i, 2:(t+1)]) - C[, rep(1, t)])^2 )
sigma_e.chain[i] <- invgamma::rinvgamma(1, t*n*ages/2, rate = aux/2) ##gerar fixando idade?
### informative priors - gamma(a, b), a = 0.01, b = 0.01
### ALPHA, BETA AND GAMMA
for (j in 1:ages) {
Y.aux <- c( y_obs[j, ] )
for(k in 2:n){
Y.aux <- c( Y.aux, y_obs[( j + (ages * (k-1)) ), ] )
}
X <- cbind(1, rep(kappa.chain[i, 2:(t+1)], n), rep(theta.chain[i-1, ], each = t))
aux.reg <- chol2inv(chol(t(X) %*% X))
mean.reg <- aux.reg %*% t(X) %*% matrix(Y.aux)
var.reg <- sigma_e.chain[i] * aux.reg
tmp <- MASS::mvrnorm(1, mean.reg, var.reg)
alpha.chain[i, j] <- tmp[1]
beta.chain[i, j] <- tmp[2]
gamma.chain[i, j] <- tmp[3]
}
### BETA & GAMMA CONSTRAINT
beta.chain[i, ] <- beta.chain[i, ]/sum(beta.chain[i, ])
gamma.chain[i, ] <- gamma.chain[i, ]/sum(gamma.chain[i, ])
### SIGMA_W
aux <- sum( (kappa.chain[i, 2:(t+1)] - nu.chain[i-1] - kappa.chain[i, 1:t])^2 ) ## years
sigma_w.chain[i] <- invgamma::rinvgamma(1, (t-1)/2, rate = aux/2)
### informative priors - gamma(a, b), a = 0.01, b = 0.01
### NU
aux <- sigma_w.chain[i]/(t-1)
aux.2 <- (kappa.chain[i, t+1] - kappa.chain[i, 1])/t
nu.chain[i] <- rnorm(1, aux.2, sqrt(aux))
#nu.chain[i] <- nu
### SIGMA_T
aux <- M - W
aux.2 <- theta.chain[i-1, ] %*% aux %*% matrix(theta.chain[i-1, ])
sigma_t.chain[i] <- invgamma::rinvgamma(1, (n-1)/2, rate = aux.2/2)
### THETA_q
for(j in 1:n){
mu0 = sum( (W[j, -j]/M[j,j])*theta.chain[i-1, -j] )
sigma0 = sigma_t.chain[i]/M[j,j]
y.hat = ( y_obs[1:ages + ages*(j-1), ] - (matrix(beta.chain[i,]) %*% kappa.chain[i, 2:(t+1)]) - matrix(alpha.chain[i,],
nrow = ages,
ncol = t) )
aux = ( sigma0*(t*sum(gamma.chain[i,]^2)) + sigma_e.chain[i] )
aux.2 = y.hat*matrix(gamma.chain[i,], nrow = ages, ncol = t)
mu1 = ( sigma0*sum(aux.2) + sigma_e.chain[i]*mu0 )/aux
sigma1 = (sigma_e.chain[i]*sigma0)/aux
theta.chain[i,j] <- rnorm(1, mu1, sqrt(sigma1))
}
### THETA CONSTRAINT
theta.chain[i,] <- theta.chain[i,] - mean(theta.chain[i,])
}
### CHAIN TREATMENT
kappa.est <- kappa.chain[seq(bn, it, by = thin), 2:(t+1)]
kappa0.est <- kappa.chain[seq(bn, it, by = thin), 1]
alpha.est <- alpha.chain[seq(bn, it, by = thin), ]
beta.est <- beta.chain[seq(bn, it, by = thin), ]
gamma.est <- gamma.chain[seq(bn, it, by = thin), ]
theta.est <- theta.chain[seq(bn, it, by = thin), ]
sigma_w.est <- sigma_w.chain[seq(bn, it, by = thin)]
sigma_t.est <- sigma_t.chain[seq(bn, it, by = thin)]
sigma_e.est <- sigma_e.chain[seq(bn, it, by = thin)]
nu.est <- nu.chain[seq(bn, it, by = thin)]
### RETURN
fit <- list(info = list(y = y_obs,
ages = ages,
t = t,
n = n,
m0 = m0,
C0 = C0,
M = M,
W = W,
it = it,
bn = bn,
thin = thin),
kappa.chain = kappa.est,
kappa0.chain = kappa0.est,
alpha.chain = alpha.est,
beta.chain = beta.est,
gamma.chain = gamma.est,
theta.chain = theta.est,
sigma_w.chain = sigma_w.est,
sigma_e.chain = sigma_e.est,
sigma_t.chain = sigma_t.est,
nu.chain = nu.est)
}
library(sf)
library(spdep)
#rj_mun <- st_read("RJ_Municipios_2022/RJ_Municipios_2022.shp")
rj_micro <- st_read("RJ_Microrregioes_2022/RJ_Microrregioes_2022.shp")
#plot(rj_mun[,c(2,5)])
plot(rj_micro[,c(2,5)])
shape_aisp_nb_val <- st_make_valid(rj_micro[,c(2,5)])
nb <- poly2nb(shape_aisp_nb_val, queen=TRUE)
# matriz de vizinhaça
W <- nb2mat(nb, style="B", zero.policy = TRUE)
M <- diag(rowSums(W))
ages <- 13  ## idades    20-24, 25-29, ..., 80+
t <- 42  ## tempo
n <- 18   ## regioes
it = 20000 #iterations
bn = 10000
thin = 5
m0 <- 0; C0 <- 10
### y_obs
y <- matrix(NA, nrow = ages*n, ncol = t)
for(i in 1:t){
aux <- i + 1979
mx <- as.data.frame(read.table(paste0("Dados_microrregioes/det/logmx_det/logmx_", as.character(aux), ".txt")))[,-1] %>%
stack()
y[,i] <- mx$values
}
ind <- as.character(mx$ind)
### missing data input (interpolando no ano, nao no espaço)
y_treat <- t(zoo::na.approx(t(y)))
y_treat[92, 42] <- y_treat[92, 41] ## repetindo valor do ultimo ano (2021) pq nao tem como interpolar
fit <- sblc(y_treat, ages, t, n, m0, C0, M, W, it = 1000, bn = 500, thin = 1)
# source("sblc_fun.R")
source("sffbs_fun.R")
sblc <- function(y, ages, t, n, m0, C0, M, W, it, bn, thin){
y_obs = y
### CHAINS
kappa.chain <- matrix(NA, nrow = it, ncol = t+1)
alpha.chain <- matrix(NA, nrow = it, ncol = ages)
beta.chain <- matrix(NA, nrow = it, ncol = ages)
gamma.chain <- matrix(NA, nrow = it, ncol = ages)
theta.chain <- matrix(NA, nrow = it, ncol = n)
sigma_w.chain <- rep(NA, it)
sigma_e.chain <- rep(NA, it)
sigma_t.chain <- rep(NA, it)
nu.chain <- rep(NA, it)
### STARTERS
alpha.chain[1, ] <- runif(ages)
beta.chain[1, ] <- runif(ages)
beta.chain[1, ] <- beta.chain[1, ]/sum(beta.chain[1, ])
gamma.chain[1, ] <- runif(ages)
gamma.chain[1, ] <- gamma.chain[1, ]/sum(gamma.chain[1, ])
theta.chain[1, ] <- runif(n)
theta.chain[1, ] <- theta.chain[1, ] - mean(theta.chain[1, ])
sigma_w.chain[1] <- 1
sigma_e.chain[1] <- 1
sigma_t.chain[1] <- 1
nu.chain[1] <- runif(1, -1, 1)
### GIBBS
pb  = progress::progress_bar$new(format = "Simulating [:bar] :percent in :elapsed",total = it, clear = FALSE, width = 60)
pb$tick()
prop = 0
set.seed(16)
for(i in 2:it){
pb$tick()
### KAPPA
fit <- ffbs_sp(y_obs = y_obs, ages = ages, t = t, n = n, m0 = m0, C0 = C0,
sigma_e = sigma_e.chain[i-1],
sigma_w = sigma_w.chain[i-1],
nu = nu.chain[i-1],
alpha = alpha.chain[i-1, ],
beta = beta.chain[i-1, ],
gamma = gamma.chain[i-1, ],
theta = theta.chain[i-1, ])
kappa.chain[i, 2:(t+1)] <- fit$kappa.bs
kappa.chain[i, 1] <- fit$kappa0.bs
### KAPPA CONSTRAINT
kappa.chain[i,] <- kappa.chain[i, ] - mean(kappa.chain[i, ])
### SIGMA_E
A <- matrix(kronecker(rep(1, n), alpha.chain[i-1, ]))
B <- matrix(kronecker(rep(1, n), beta.chain[i-1, ]))
C <- matrix(kronecker(theta.chain[i-1, ], gamma.chain[i-1, ]))
aux <- sum( (y_obs - A[, rep(1, t)] - (B %*% kappa.chain[i, 2:(t+1)]) - C[, rep(1, t)])^2 )
sigma_e.chain[i] <- invgamma::rinvgamma(1, t*n*ages/2, rate = aux/2) ##gerar fixando idade?
### informative priors - gamma(a, b), a = 0.01, b = 0.01
### ALPHA, BETA AND GAMMA
for (j in 1:ages) {
Y.aux <- c( y_obs[j, ] )
for(k in 2:n){
Y.aux <- c( Y.aux, y_obs[( j + (ages * (k-1)) ), ] )
}
X <- cbind(1, rep(kappa.chain[i, 2:(t+1)], n), rep(theta.chain[i-1, ], each = t))
aux.reg <- chol2inv(chol(t(X) %*% X))
mean.reg <- aux.reg %*% t(X) %*% matrix(Y.aux)
var.reg <- sigma_e.chain[i] * aux.reg
tmp <- MASS::mvrnorm(1, mean.reg, var.reg)
alpha.chain[i, j] <- tmp[1]
beta.chain[i, j] <- tmp[2]
gamma.chain[i, j] <- tmp[3]
}
### BETA & GAMMA CONSTRAINT
beta.chain[i, ] <- beta.chain[i, ]/sum(beta.chain[i, ])
gamma.chain[i, ] <- gamma.chain[i, ]/sum(gamma.chain[i, ])
### SIGMA_W
aux <- sum( (kappa.chain[i, 2:(t+1)] - nu.chain[i-1] - kappa.chain[i, 1:t])^2 ) ## years
sigma_w.chain[i] <- invgamma::rinvgamma(1, (t-1)/2, rate = aux/2)
### informative priors - gamma(a, b), a = 0.01, b = 0.01
### NU
aux <- sigma_w.chain[i]/(t-1)
aux.2 <- (kappa.chain[i, t+1] - kappa.chain[i, 1])/t
nu.chain[i] <- rnorm(1, aux.2, sqrt(aux))
#nu.chain[i] <- nu
### SIGMA_T
aux <- M - W
aux.2 <- theta.chain[i-1, ] %*% aux %*% matrix(theta.chain[i-1, ])
sigma_t.chain[i] <- invgamma::rinvgamma(1, (n-1)/2, rate = aux.2/2)
### THETA_q
for(j in 1:n){
mu0 = sum( (W[j, -j]/M[j,j])*theta.chain[i-1, -j] )
sigma0 = sigma_t.chain[i]/M[j,j]
y.hat = ( y_obs[1:ages + ages*(j-1), ] - (matrix(beta.chain[i,]) %*% kappa.chain[i, 2:(t+1)]) - matrix(alpha.chain[i,],
nrow = ages,
ncol = t) )
aux = ( sigma0*(t*sum(gamma.chain[i,]^2)) + sigma_e.chain[i] )
aux.2 = y.hat*matrix(gamma.chain[i,], nrow = ages, ncol = t)
mu1 = ( sigma0*sum(aux.2) + sigma_e.chain[i]*mu0 )/aux
sigma1 = (sigma_e.chain[i]*sigma0)/aux
theta.chain[i,j] <- rnorm(1, mu1, sqrt(sigma1))
}
### THETA CONSTRAINT
theta.chain[i,] <- theta.chain[i,] - mean(theta.chain[i,])
}
### CHAIN TREATMENT
kappa.est <- kappa.chain[seq(bn, it, by = thin), 2:(t+1)]
kappa0.est <- kappa.chain[seq(bn, it, by = thin), 1]
alpha.est <- alpha.chain[seq(bn, it, by = thin), ]
beta.est <- beta.chain[seq(bn, it, by = thin), ]
gamma.est <- gamma.chain[seq(bn, it, by = thin), ]
theta.est <- theta.chain[seq(bn, it, by = thin), ]
sigma_w.est <- sigma_w.chain[seq(bn, it, by = thin)]
sigma_t.est <- sigma_t.chain[seq(bn, it, by = thin)]
sigma_e.est <- sigma_e.chain[seq(bn, it, by = thin)]
nu.est <- nu.chain[seq(bn, it, by = thin)]
### RETURN
fit <- list(info = list(y = y_obs,
ages = ages,
t = t,
n = n,
m0 = m0,
C0 = C0,
M = M,
W = W,
it = it,
bn = bn,
thin = thin),
kappa.chain = kappa.est,
kappa0.chain = kappa0.est,
alpha.chain = alpha.est,
beta.chain = beta.est,
gamma.chain = gamma.est,
theta.chain = theta.est,
sigma_w.chain = sigma_w.est,
sigma_e.chain = sigma_e.est,
sigma_t.chain = sigma_t.est,
nu.chain = nu.est)
}
fit <- sblc(y_treat, ages, t, n, m0, C0, M, W, it = 1000, bn = 500, thin = 1)
plot.ts(kappa.chain[bn:it ,1])
plot.ts(fit$kappa.chain[bn:it ,1])
plot.ts(fit$kappa.chain[ ,1])
plot.ts(fit$kappa.chain[ ,10])
plot.ts(fit$kappa.chain[ ,20])
plot.ts(fit$kappa.chain[ ,30])
plot.ts(fit$alpha.chain[ ,1])
plot.ts(fit$alpha.chain[ ,10])
plot.ts(fit$alpha.chain[ ,20])
plot.ts(fit$alpha.chain[ ,13])
plot.ts(fit$beta.chain[ ,1])
plot.ts(fit$beta.chain[ ,10])
plot.ts(fit$beta.chain[ ,13])
plot.ts(fit$gamma.chain[ ,1])
plot.ts(fit$gamma.chain[ ,10])
plot.ts(fit$gamma.chain[ ,13])
plot.ts(fit$theta.chain[ ,1])
plot.ts(fit$theta.chain[ ,10])
plot.ts(fit$theta.chain[ ,13])
graphics.off()
fit$nu.chain
plot.ts(fit$nu.chain)
plot.ts(fit$sigma_w.chain)
plot.ts(fit$sigma_e.chain)
plot.ts(fit$sigma_t.chain)
plot.ts(apply(theta.chain, 2, median))
plot.ts(apply(fit$theta.chain, 2, median))
acf(fit$kappa.chain[ ,1])
acf(fit$kappa.chain[ ,10])
acf(fit$kappa.chain[ ,20])
acf(fit$kappa.chain[ ,30])
acf(fit$beta.chain[ ,1])
acf(fit$beta.chain[ ,10])
acf(fit$beta.chain[ ,13])
acf(fit$gamma.chain[ ,1])
acf(fit$gamma.chain[ ,10])
acf(fit$gamma.chain[ ,13])
acf(fit$theta.chain[ ,1])
acf(fit$theta.chain[ ,10])
acf(fit$theta.chain[ ,13])
graphics.off()
plot.ts(fit$nu.chain)
plot.ts(fit$sigma_w.chain)
plot.ts(fit$sigma_e.chain)
plot.ts(fit$sigma_t.chain)
acf(fit$nu.chain)
acf(fit$sigma_w.chain)
plot.ts(fit$sigma_e.chain)
acf(fit$sigma_e.chain)
acf(fit$sigma_t.chain)
